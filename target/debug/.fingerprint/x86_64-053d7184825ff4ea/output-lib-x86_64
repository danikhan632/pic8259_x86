{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1404,"byte_end":1407,"line_start":45,"line_end":45,"column_start":42,"column_end":45,"is_primary":true,"text":[{"text":"                    VirtAddr::new_unsafe(val)","highlight_start":42,"highlight_end":45}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2830,"byte_end":2863,"line_start":89,"line_end":89,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(FS, \"fs\", FsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1383,"byte_end":1403,"line_start":45,"line_end":45,"column_start":21,"column_end":41,"is_primary":false,"text":[{"text":"                    VirtAddr::new_unsafe(val)","highlight_start":21,"highlight_end":41}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2830,"byte_end":2863,"line_start":89,"line_end":89,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(FS, \"fs\", FsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":4379,"byte_end":4388,"line_start":111,"line_end":111,"column_start":36,"column_end":45,"is_primary":false,"text":[{"text":"    pub const unsafe fn new_unsafe(addr: u32) -> VirtAddr {","highlight_start":36,"highlight_end":45}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":4368,"byte_end":4378,"line_start":111,"line_end":111,"column_start":25,"column_end":35,"is_primary":true,"text":[{"text":"    pub const unsafe fn new_unsafe(addr: u32) -> VirtAddr {","highlight_start":25,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1407,"byte_end":1407,"line_start":45,"line_end":45,"column_start":45,"column_end":45,"is_primary":true,"text":[{"text":"                    VirtAddr::new_unsafe(val)","highlight_start":45,"highlight_end":45}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2830,"byte_end":2863,"line_start":89,"line_end":89,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(FS, \"fs\", FsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs:45:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    VirtAddr::new_unsafe(val)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0msegment64_impl!(FS, \"fs\", FsBase);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:111:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub const unsafe fn new_unsafe(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `segment64_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    VirtAddr::new_unsafe(val\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1588,"byte_end":1594,"line_start":51,"line_end":51,"column_start":72,"column_end":78,"is_primary":true,"text":[{"text":"                    asm!(concat!(\"wr\", $name, \"base {}\"), in(reg) base.as_u64(), options(nostack, preserves_flags));","highlight_start":72,"highlight_end":78}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2830,"byte_end":2863,"line_start":89,"line_end":89,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(FS, \"fs\", FsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1588,"byte_end":1594,"line_start":51,"line_end":51,"column_start":72,"column_end":78,"is_primary":true,"text":[{"text":"                    asm!(concat!(\"wr\", $name, \"base {}\"), in(reg) base.as_u64(), options(nostack, preserves_flags));","highlight_start":72,"highlight_end":78}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2830,"byte_end":2863,"line_start":89,"line_end":89,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(FS, \"fs\", FsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs:51:72\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    asm!(concat!(\"wr\", $name, \"base {}\"), in(reg) base.as_u64(), options(nostack, preserves_flags));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0msegment64_impl!(FS, \"fs\", FsBase);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `segment64_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1404,"byte_end":1407,"line_start":45,"line_end":45,"column_start":42,"column_end":45,"is_primary":true,"text":[{"text":"                    VirtAddr::new_unsafe(val)","highlight_start":42,"highlight_end":45}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2890,"byte_end":2923,"line_start":91,"line_end":91,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(GS, \"gs\", GsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1383,"byte_end":1403,"line_start":45,"line_end":45,"column_start":21,"column_end":41,"is_primary":false,"text":[{"text":"                    VirtAddr::new_unsafe(val)","highlight_start":21,"highlight_end":41}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2890,"byte_end":2923,"line_start":91,"line_end":91,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(GS, \"gs\", GsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":4379,"byte_end":4388,"line_start":111,"line_end":111,"column_start":36,"column_end":45,"is_primary":false,"text":[{"text":"    pub const unsafe fn new_unsafe(addr: u32) -> VirtAddr {","highlight_start":36,"highlight_end":45}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":4368,"byte_end":4378,"line_start":111,"line_end":111,"column_start":25,"column_end":35,"is_primary":true,"text":[{"text":"    pub const unsafe fn new_unsafe(addr: u32) -> VirtAddr {","highlight_start":25,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1407,"byte_end":1407,"line_start":45,"line_end":45,"column_start":45,"column_end":45,"is_primary":true,"text":[{"text":"                    VirtAddr::new_unsafe(val)","highlight_start":45,"highlight_end":45}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2890,"byte_end":2923,"line_start":91,"line_end":91,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(GS, \"gs\", GsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs:45:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    VirtAddr::new_unsafe(val)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m91\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0msegment64_impl!(GS, \"gs\", GsBase);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:111:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub const unsafe fn new_unsafe(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `segment64_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    VirtAddr::new_unsafe(val\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1588,"byte_end":1594,"line_start":51,"line_end":51,"column_start":72,"column_end":78,"is_primary":true,"text":[{"text":"                    asm!(concat!(\"wr\", $name, \"base {}\"), in(reg) base.as_u64(), options(nostack, preserves_flags));","highlight_start":72,"highlight_end":78}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2890,"byte_end":2923,"line_start":91,"line_end":91,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(GS, \"gs\", GsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":1588,"byte_end":1594,"line_start":51,"line_end":51,"column_start":72,"column_end":78,"is_primary":true,"text":[{"text":"                    asm!(concat!(\"wr\", $name, \"base {}\"), in(reg) base.as_u64(), options(nostack, preserves_flags));","highlight_start":72,"highlight_end":78}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":2890,"byte_end":2923,"line_start":91,"line_end":91,"column_start":1,"column_end":34,"is_primary":false,"text":[{"text":"segment64_impl!(GS, \"gs\", GsBase);","highlight_start":1,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"segment64_impl!","def_site_span":{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":994,"byte_end":1021,"line_start":37,"line_end":37,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"macro_rules! segment64_impl {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs:51:72\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    asm!(concat!(\"wr\", $name, \"base {}\"), in(reg) base.as_u64(), options(nostack, preserves_flags));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m91\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0msegment64_impl!(GS, \"gs\", GsBase);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `segment64_impl` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":5338,"byte_end":5341,"line_start":170,"line_end":170,"column_start":43,"column_end":46,"is_primary":true,"text":[{"text":"    unsafe { FS::write_base(VirtAddr::new(val)) }","highlight_start":43,"highlight_end":46}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":5324,"byte_end":5337,"line_start":170,"line_end":170,"column_start":29,"column_end":42,"is_primary":false,"text":[{"text":"    unsafe { FS::write_base(VirtAddr::new(val)) }","highlight_start":29,"highlight_end":42}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":5341,"byte_end":5341,"line_start":170,"line_end":170,"column_start":46,"column_end":46,"is_primary":true,"text":[{"text":"    unsafe { FS::write_base(VirtAddr::new(val)) }","highlight_start":46,"highlight_end":46}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs:170:43\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m170\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    unsafe { FS::write_base(VirtAddr::new(val)) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m170\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    unsafe { FS::write_base(VirtAddr::new(val\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m)) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":5555,"byte_end":5561,"line_start":177,"line_end":177,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"    FS::read_base().as_u64()","highlight_start":21,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":5555,"byte_end":5561,"line_start":177,"line_end":177,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"    FS::read_base().as_u64()","highlight_start":21,"highlight_end":27}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs:177:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m177\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    FS::read_base().as_u64()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":5856,"byte_end":5859,"line_start":186,"line_end":186,"column_start":43,"column_end":46,"is_primary":true,"text":[{"text":"    unsafe { GS::write_base(VirtAddr::new(val)) }","highlight_start":43,"highlight_end":46}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":5842,"byte_end":5855,"line_start":186,"line_end":186,"column_start":29,"column_end":42,"is_primary":false,"text":[{"text":"    unsafe { GS::write_base(VirtAddr::new(val)) }","highlight_start":29,"highlight_end":42}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":5859,"byte_end":5859,"line_start":186,"line_end":186,"column_start":46,"column_end":46,"is_primary":true,"text":[{"text":"    unsafe { GS::write_base(VirtAddr::new(val)) }","highlight_start":46,"highlight_end":46}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs:186:43\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    unsafe { GS::write_base(VirtAddr::new(val)) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    unsafe { GS::write_base(VirtAddr::new(val\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m)) }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":6073,"byte_end":6079,"line_start":193,"line_end":193,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"    GS::read_base().as_u64()","highlight_start":21,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs","byte_start":6073,"byte_end":6079,"line_start":193,"line_end":193,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"    GS::read_base().as_u64()","highlight_start":21,"highlight_end":27}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/segmentation.rs:193:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m193\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    GS::read_base().as_u64()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/tlb.rs","byte_start":278,"byte_end":284,"line_start":10,"line_end":10,"column_start":42,"column_end":48,"is_primary":true,"text":[{"text":"        asm!(\"invlpg [{}]\", in(reg) addr.as_u64(), options(nostack, preserves_flags));","highlight_start":42,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/tlb.rs","byte_start":278,"byte_end":284,"line_start":10,"line_end":10,"column_start":42,"column_end":48,"is_primary":true,"text":[{"text":"        asm!(\"invlpg [{}]\", in(reg) addr.as_u64(), options(nostack, preserves_flags));","highlight_start":42,"highlight_end":48}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/tlb.rs:10:42\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        asm!(\"invlpg [{}]\", in(reg) addr.as_u64(), options(nostack, preserves_flags));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/tlb.rs","byte_start":2643,"byte_end":2649,"line_start":86,"line_end":86,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"            desc.address = addr.as_u64()","highlight_start":33,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/tlb.rs","byte_start":2643,"byte_end":2649,"line_start":86,"line_end":86,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"            desc.address = addr.as_u64()","highlight_start":33,"highlight_end":39}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/tlb.rs:86:33\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m86\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            desc.address = addr.as_u64()\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/mod.rs","byte_start":1549,"byte_end":1552,"line_start":52,"line_end":52,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"    crate::VirtAddr::new(rip)","highlight_start":26,"highlight_end":29}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/mod.rs","byte_start":1528,"byte_end":1548,"line_start":52,"line_end":52,"column_start":5,"column_end":25,"is_primary":false,"text":[{"text":"    crate::VirtAddr::new(rip)","highlight_start":5,"highlight_end":25}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/mod.rs","byte_start":1552,"byte_end":1552,"line_start":52,"line_end":52,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"    crate::VirtAddr::new(rip)","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/instructions/mod.rs:52:26\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    crate::VirtAddr::new(rip)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    crate::VirtAddr::new(rip\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":10193,"byte_end":10209,"line_start":244,"line_end":244,"column_start":27,"column_end":43,"is_primary":true,"text":[{"text":"            VirtAddr::new(Self::read_raw())","highlight_start":27,"highlight_end":43}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":10179,"byte_end":10192,"line_start":244,"line_end":244,"column_start":13,"column_end":26,"is_primary":false,"text":[{"text":"            VirtAddr::new(Self::read_raw())","highlight_start":13,"highlight_end":26}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":10209,"byte_end":10209,"line_start":244,"line_end":244,"column_start":43,"column_end":43,"is_primary":true,"text":[{"text":"            VirtAddr::new(Self::read_raw())","highlight_start":43,"highlight_end":43}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs:244:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            VirtAddr::new(Self::read_raw())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            VirtAddr::new(Self::read_raw()\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                           \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":11201,"byte_end":11231,"line_start":278,"line_end":278,"column_start":38,"column_end":68,"is_primary":true,"text":[{"text":"            let addr = PhysAddr::new(value & 0x_000f_ffff_ffff_f000);","highlight_start":38,"highlight_end":68}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":11187,"byte_end":11200,"line_start":278,"line_end":278,"column_start":24,"column_end":37,"is_primary":false,"text":[{"text":"            let addr = PhysAddr::new(value & 0x_000f_ffff_ffff_f000);","highlight_start":24,"highlight_end":37}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":12560,"byte_end":12569,"line_start":428,"line_end":428,"column_start":22,"column_end":31,"is_primary":false,"text":[{"text":"    pub const fn new(addr: u32) -> Self {","highlight_start":22,"highlight_end":31}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":12556,"byte_end":12559,"line_start":428,"line_end":428,"column_start":18,"column_end":21,"is_primary":true,"text":[{"text":"    pub const fn new(addr: u32) -> Self {","highlight_start":18,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":11201,"byte_end":11201,"line_start":278,"line_end":278,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"            let addr = PhysAddr::new(value & 0x_000f_ffff_ffff_f000);","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":11231,"byte_end":11231,"line_start":278,"line_end":278,"column_start":68,"column_end":68,"is_primary":true,"text":[{"text":"            let addr = PhysAddr::new(value & 0x_000f_ffff_ffff_f000);","highlight_start":68,"highlight_end":68}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs:278:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m278\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let addr = PhysAddr::new(value & 0x_000f_ffff_ffff_f000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:428:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m428\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub const fn new(addr: u32) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m278\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let addr = PhysAddr::new(\u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0mvalue & 0x_000f_ffff_ffff_f000\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `PhysAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1762,"byte_end":1781,"line_start":42,"line_end":42,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct PhysAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":13076,"byte_end":13082,"line_start":328,"line_end":328,"column_start":30,"column_end":36,"is_primary":true,"text":[{"text":"            let value = addr.as_u64() | val as u64;","highlight_start":30,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs","byte_start":13076,"byte_end":13082,"line_start":328,"line_end":328,"column_start":30,"column_end":36,"is_primary":true,"text":[{"text":"            let value = addr.as_u64() | val as u64;","highlight_start":30,"highlight_end":36}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `PhysAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/control.rs:328:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m328\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let value = addr.as_u64() | val as u64;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:42:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct PhysAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":8333,"byte_end":8349,"line_start":294,"line_end":294,"column_start":36,"column_end":52,"is_primary":true,"text":[{"text":"            VirtAddr::new(unsafe { Self::MSR.read() })","highlight_start":36,"highlight_end":52}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":8349,"byte_end":8349,"line_start":294,"line_end":294,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"            VirtAddr::new(unsafe { Self::MSR.read() })","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:294:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            VirtAddr::new(unsafe { Self::MSR.read() })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            VirtAddr::new(unsafe { Self::MSR.read()\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":8710,"byte_end":8716,"line_start":304,"line_end":304,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            unsafe { msr.write(address.as_u64()) };","highlight_start":40,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":8710,"byte_end":8716,"line_start":304,"line_end":304,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            unsafe { msr.write(address.as_u64()) };","highlight_start":40,"highlight_end":46}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:304:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m304\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            unsafe { msr.write(address.as_u64()) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":9035,"byte_end":9051,"line_start":315,"line_end":315,"column_start":36,"column_end":52,"is_primary":true,"text":[{"text":"            VirtAddr::new(unsafe { Self::MSR.read() })","highlight_start":36,"highlight_end":52}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":9051,"byte_end":9051,"line_start":315,"line_end":315,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"            VirtAddr::new(unsafe { Self::MSR.read() })","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:315:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m315\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            VirtAddr::new(unsafe { Self::MSR.read() })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m315\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            VirtAddr::new(unsafe { Self::MSR.read()\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":9412,"byte_end":9418,"line_start":325,"line_end":325,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            unsafe { msr.write(address.as_u64()) };","highlight_start":40,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":9412,"byte_end":9418,"line_start":325,"line_end":325,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            unsafe { msr.write(address.as_u64()) };","highlight_start":40,"highlight_end":46}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:325:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m325\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            unsafe { msr.write(address.as_u64()) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":9607,"byte_end":9623,"line_start":333,"line_end":333,"column_start":36,"column_end":52,"is_primary":true,"text":[{"text":"            VirtAddr::new(unsafe { Self::MSR.read() })","highlight_start":36,"highlight_end":52}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":9623,"byte_end":9623,"line_start":333,"line_end":333,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"            VirtAddr::new(unsafe { Self::MSR.read() })","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:333:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            VirtAddr::new(unsafe { Self::MSR.read() })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            VirtAddr::new(unsafe { Self::MSR.read()\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":9846,"byte_end":9852,"line_start":340,"line_end":340,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            unsafe { msr.write(address.as_u64()) };","highlight_start":40,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":9846,"byte_end":9852,"line_start":340,"line_end":340,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            unsafe { msr.write(address.as_u64()) };","highlight_start":40,"highlight_end":46}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:340:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m340\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            unsafe { msr.write(address.as_u64()) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":14049,"byte_end":14065,"line_start":453,"line_end":453,"column_start":36,"column_end":52,"is_primary":true,"text":[{"text":"            VirtAddr::new(unsafe { Self::MSR.read() })","highlight_start":36,"highlight_end":52}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":14065,"byte_end":14065,"line_start":453,"line_end":453,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"            VirtAddr::new(unsafe { Self::MSR.read() })","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:453:36\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m453\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            VirtAddr::new(unsafe { Self::MSR.read() })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m453\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            VirtAddr::new(unsafe { Self::MSR.read()\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m })\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":14333,"byte_end":14339,"line_start":461,"line_end":461,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            unsafe { msr.write(address.as_u64()) };","highlight_start":40,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":14333,"byte_end":14339,"line_start":461,"line_end":461,"column_start":40,"column_end":46,"is_primary":true,"text":[{"text":"            unsafe { msr.write(address.as_u64()) };","highlight_start":40,"highlight_end":46}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:461:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            unsafe { msr.write(address.as_u64()) };\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":16312,"byte_end":16349,"line_start":514,"line_end":514,"column_start":56,"column_end":93,"is_primary":true,"text":[{"text":"                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))","highlight_start":56,"highlight_end":93}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":16298,"byte_end":16311,"line_start":514,"line_end":514,"column_start":42,"column_end":55,"is_primary":false,"text":[{"text":"                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))","highlight_start":42,"highlight_end":55}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":16312,"byte_end":16312,"line_start":514,"line_end":514,"column_start":56,"column_end":56,"is_primary":true,"text":[{"text":"                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))","highlight_start":56,"highlight_end":56}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":16349,"byte_end":16349,"line_start":514,"line_end":514,"column_start":93,"column_end":93,"is_primary":true,"text":[{"text":"                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))","highlight_start":93,"highlight_end":93}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:514:56\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                Page::from_start_address(VirtAddr::new(\u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0mvalue & !(Page::<Size4KiB>::SIZE - 1)\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                        \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":16616,"byte_end":16622,"line_start":523,"line_end":523,"column_start":74,"column_end":80,"is_primary":true,"text":[{"text":"            Self::write_raw(flags.bits() | legacy_bitmap.start_address().as_u64());","highlight_start":74,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":16616,"byte_end":16622,"line_start":523,"line_end":523,"column_start":74,"column_end":80,"is_primary":true,"text":[{"text":"            Self::write_raw(flags.bits() | legacy_bitmap.start_address().as_u64());","highlight_start":74,"highlight_end":80}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:523:74\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m523\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Self::write_raw(flags.bits() | legacy_bitmap.start_address().as_u64());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":17367,"byte_end":17404,"line_start":549,"line_end":549,"column_start":56,"column_end":93,"is_primary":true,"text":[{"text":"                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))","highlight_start":56,"highlight_end":93}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":17353,"byte_end":17366,"line_start":549,"line_end":549,"column_start":42,"column_end":55,"is_primary":false,"text":[{"text":"                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))","highlight_start":42,"highlight_end":55}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":17367,"byte_end":17367,"line_start":549,"line_end":549,"column_start":56,"column_end":56,"is_primary":true,"text":[{"text":"                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))","highlight_start":56,"highlight_end":56}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":17404,"byte_end":17404,"line_start":549,"line_end":549,"column_start":93,"column_end":93,"is_primary":true,"text":[{"text":"                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))","highlight_start":93,"highlight_end":93}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:549:56\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m549\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Page::from_start_address(VirtAddr::new(value & !(Page::<Size4KiB>::SIZE - 1)))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m549\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                Page::from_start_address(VirtAddr::new(\u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0mvalue & !(Page::<Size4KiB>::SIZE - 1)\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                        \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":17671,"byte_end":17677,"line_start":558,"line_end":558,"column_start":74,"column_end":80,"is_primary":true,"text":[{"text":"            Self::write_raw(flags.bits() | legacy_bitmap.start_address().as_u64());","highlight_start":74,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs","byte_start":17671,"byte_end":17677,"line_start":558,"line_end":558,"column_start":74,"column_end":80,"is_primary":true,"text":[{"text":"            Self::write_raw(flags.bits() | legacy_bitmap.start_address().as_u64());","highlight_start":74,"highlight_end":80}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/registers/model_specific.rs:558:74\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m558\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Self::write_raw(flags.bits() | legacy_bitmap.start_address().as_u64());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/gdt.rs","byte_start":6600,"byte_end":6626,"line_start":180,"line_end":180,"column_start":40,"column_end":66,"is_primary":true,"text":[{"text":"            base: crate::VirtAddr::new(self.table.as_ptr() as u64),","highlight_start":40,"highlight_end":66}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/gdt.rs","byte_start":6579,"byte_end":6599,"line_start":180,"line_end":180,"column_start":19,"column_end":39,"is_primary":false,"text":[{"text":"            base: crate::VirtAddr::new(self.table.as_ptr() as u64),","highlight_start":19,"highlight_end":39}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/gdt.rs","byte_start":6600,"byte_end":6600,"line_start":180,"line_end":180,"column_start":40,"column_end":40,"is_primary":true,"text":[{"text":"            base: crate::VirtAddr::new(self.table.as_ptr() as u64),","highlight_start":40,"highlight_end":40}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/gdt.rs","byte_start":6626,"byte_end":6626,"line_start":180,"line_end":180,"column_start":66,"column_end":66,"is_primary":true,"text":[{"text":"            base: crate::VirtAddr::new(self.table.as_ptr() as u64),","highlight_start":66,"highlight_end":66}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/gdt.rs:180:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m180\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            base: crate::VirtAddr::new(self.table.as_ptr() as u64),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m180\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            base: crate::VirtAddr::new(\u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0mself.table.as_ptr() as u64\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":23368,"byte_end":23391,"line_start":485,"line_end":485,"column_start":33,"column_end":56,"is_primary":true,"text":[{"text":"            base: VirtAddr::new(self as *const _ as u64),","highlight_start":33,"highlight_end":56}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":23354,"byte_end":23367,"line_start":485,"line_end":485,"column_start":19,"column_end":32,"is_primary":false,"text":[{"text":"            base: VirtAddr::new(self as *const _ as u64),","highlight_start":19,"highlight_end":32}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":23368,"byte_end":23368,"line_start":485,"line_end":485,"column_start":33,"column_end":33,"is_primary":true,"text":[{"text":"            base: VirtAddr::new(self as *const _ as u64),","highlight_start":33,"highlight_end":33}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":23391,"byte_end":23391,"line_start":485,"line_end":485,"column_start":56,"column_end":56,"is_primary":true,"text":[{"text":"            base: VirtAddr::new(self as *const _ as u64),","highlight_start":56,"highlight_end":56}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs:485:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m485\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            base: VirtAddr::new(self as *const _ as u64),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m485\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            base: VirtAddr::new(\u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0mself as *const _ as u64\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":32995,"byte_end":33001,"line_start":724,"line_end":724,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"        let addr = addr.as_u64();","highlight_start":25,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":32995,"byte_end":33001,"line_start":724,"line_end":724,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"        let addr = addr.as_u64();","highlight_start":25,"highlight_end":31}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs:724:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m724\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let addr = addr.as_u64();\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":33725,"byte_end":33729,"line_start":744,"line_end":744,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"        VirtAddr::new_truncate(addr)","highlight_start":32,"highlight_end":36}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":33702,"byte_end":33724,"line_start":744,"line_end":744,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        VirtAddr::new_truncate(addr)","highlight_start":9,"highlight_end":31}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":3931,"byte_end":3940,"line_start":99,"line_end":99,"column_start":31,"column_end":40,"is_primary":false,"text":[{"text":"    pub const fn new_truncate(addr: u32) -> VirtAddr {","highlight_start":31,"highlight_end":40}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":3918,"byte_end":3930,"line_start":99,"line_end":99,"column_start":18,"column_end":30,"is_primary":true,"text":[{"text":"    pub const fn new_truncate(addr: u32) -> VirtAddr {","highlight_start":18,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs","byte_start":33729,"byte_end":33729,"line_start":744,"line_end":744,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"        VirtAddr::new_truncate(addr)","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/idt.rs:744:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m744\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        VirtAddr::new_truncate(addr)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:99:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub const fn new_truncate(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m744\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        VirtAddr::new_truncate(addr\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"the trait bound `u32: From<u64>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":919,"byte_end":926,"line_start":25,"line_end":25,"column_start":32,"column_end":39,"is_primary":true,"text":[{"text":"        if !address.is_aligned(S::SIZE) {","highlight_start":32,"highlight_end":39}],"label":"the trait `From<u64>` is not implemented for `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":908,"byte_end":918,"line_start":25,"line_end":25,"column_start":21,"column_end":31,"is_primary":false,"text":[{"text":"        if !address.is_aligned(S::SIZE) {","highlight_start":21,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `Into<u32>` for `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `PhysAddr::is_aligned`","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":14862,"byte_end":14872,"line_start":512,"line_end":512,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"    pub fn is_aligned<U>(self, align: U) -> bool","highlight_start":12,"highlight_end":22}],"label":"required by a bound in this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":14921,"byte_end":14930,"line_start":514,"line_end":514,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"        U: Into<u32>,","highlight_start":12,"highlight_end":21}],"label":"required by this bound in `PhysAddr::is_aligned`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u32: From<u64>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs:25:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if !address.is_aligned(S::SIZE) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<u64>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `Into<u32>` for `u64`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `PhysAddr::is_aligned`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:514:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m512\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn is_aligned<U>(self, align: U) -> bool\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        U: Into<u32>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PhysAddr::is_aligned`\u001b[0m\n\n"}
{"message":"the trait bound `u32: From<u64>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":1717,"byte_end":1724,"line_start":51,"line_end":51,"column_start":47,"column_end":54,"is_primary":true,"text":[{"text":"            start_address: address.align_down(S::SIZE),","highlight_start":47,"highlight_end":54}],"label":"the trait `From<u64>` is not implemented for `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":1706,"byte_end":1716,"line_start":51,"line_end":51,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"            start_address: address.align_down(S::SIZE),","highlight_start":36,"highlight_end":46}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `Into<u32>` for `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `PhysAddr::align_down`","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":14631,"byte_end":14641,"line_start":503,"line_end":503,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"    pub fn align_down<U>(self, align: U) -> Self","highlight_start":12,"highlight_end":22}],"label":"required by a bound in this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":14690,"byte_end":14699,"line_start":505,"line_end":505,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"        U: Into<u32>,","highlight_start":12,"highlight_end":21}],"label":"required by this bound in `PhysAddr::align_down`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u32: From<u64>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs:51:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            start_address: address.align_down(S::SIZE),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<u64>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `Into<u32>` for `u64`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `PhysAddr::align_down`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:505:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m503\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn align_down<U>(self, align: U) -> Self\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m504\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m505\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        U: Into<u32>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PhysAddr::align_down`\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `PhysAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1762,"byte_end":1781,"line_start":42,"line_end":42,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct PhysAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":2874,"byte_end":2880,"line_start":90,"line_end":90,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"            self.start_address().as_u64()","highlight_start":34,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":2874,"byte_end":2880,"line_start":90,"line_end":90,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"            self.start_address().as_u64()","highlight_start":34,"highlight_end":40}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `PhysAddr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs:90:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            self.start_address().as_u64()\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:42:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct PhysAddr(u32);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"cannot add `u64` to `PhysAddr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":3091,"byte_end":3092,"line_start":99,"line_end":99,"column_start":60,"column_end":61,"is_primary":true,"text":[{"text":"        PhysFrame::containing_address(self.start_address() + rhs * S::SIZE)","highlight_start":60,"highlight_end":61}],"label":"no implementation for `PhysAddr + u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Add<u64>` is not implemented for `PhysAddr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Add<Rhs>`:\n  <PhysAddr as Add<u32>>\n  <PhysAddr as Add<usize>>","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot add `u64` to `PhysAddr`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs:99:60\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m99\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        PhysFrame::containing_address(self.start_address() + rhs * S::SIZE)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `PhysAddr + u64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Add<u64>` is not implemented for `PhysAddr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Add<Rhs>`:\u001b[0m\n\u001b[0m             <PhysAddr as Add<u32>>\u001b[0m\n\u001b[0m             <PhysAddr as Add<usize>>\u001b[0m\n\n"}
{"message":"cannot subtract `u64` from `PhysAddr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":3450,"byte_end":3451,"line_start":114,"line_end":114,"column_start":60,"column_end":61,"is_primary":true,"text":[{"text":"        PhysFrame::containing_address(self.start_address() - rhs * S::SIZE)","highlight_start":60,"highlight_end":61}],"label":"no implementation for `PhysAddr - u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sub<u64>` is not implemented for `PhysAddr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sub<Rhs>`:\n  <PhysAddr as Sub<u32>>\n  <PhysAddr as Sub<usize>>\n  <PhysAddr as Sub>","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot subtract `u64` from `PhysAddr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs:114:60\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        PhysFrame::containing_address(self.start_address() - rhs * S::SIZE)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `PhysAddr - u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sub<u64>` is not implemented for `PhysAddr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sub<Rhs>`:\u001b[0m\n\u001b[0m              <PhysAddr as Sub<u32>>\u001b[0m\n\u001b[0m              <PhysAddr as Sub<usize>>\u001b[0m\n\u001b[0m              <PhysAddr as Sub>\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":3818,"byte_end":3825,"line_start":129,"line_end":129,"column_start":52,"column_end":59,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":52,"highlight_end":59}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs:129:52\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (self.start_address - rhs.start_address) / S::SIZE\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":3775,"byte_end":3825,"line_start":129,"line_end":129,"column_start":9,"column_end":59,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":9,"highlight_end":59}],"label":"expected `u64`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":3752,"byte_end":3764,"line_start":128,"line_end":128,"column_start":40,"column_end":52,"is_primary":false,"text":[{"text":"    fn sub(self, rhs: PhysFrame<S>) -> Self::Output {","highlight_start":40,"highlight_end":52}],"label":"expected `u64` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u32` to a `u64`","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":3775,"byte_end":3775,"line_start":129,"line_end":129,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":3825,"byte_end":3825,"line_start":129,"line_end":129,"column_start":59,"column_end":59,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":59,"highlight_end":59}],"label":null,"suggested_replacement":").into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs:129:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m128\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn sub(self, rhs: PhysFrame<S>) -> Self::Output {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `u64` because of return type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (self.start_address - rhs.start_address) / S::SIZE\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u64`, found `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u32` to a `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0m(self.start_address - rhs.start_address) / S::SIZE\u001b[0m\u001b[0m\u001b[38;5;10m).into()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[38;5;10m++++++++\u001b[0m\n\n"}
{"message":"cannot divide `u32` by `u64`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs","byte_start":3816,"byte_end":3817,"line_start":129,"line_end":129,"column_start":50,"column_end":51,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":50,"highlight_end":51}],"label":"no implementation for `u32 / u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Div<u64>` is not implemented for `u32`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Div<Rhs>`:\n  <&'a f32 as Div<f32>>\n  <&'a f64 as Div<f64>>\n  <&'a i128 as Div<i128>>\n  <&'a i16 as Div<i16>>\n  <&'a i32 as Div<i32>>\n  <&'a i64 as Div<i64>>\n  <&'a i8 as Div<i8>>\n  <&'a isize as Div<isize>>\nand 54 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot divide `u32` by `u64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/frame.rs:129:50\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m129\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (self.start_address - rhs.start_address) / S::SIZE\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `u32 / u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Div<u64>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Div<Rhs>`:\u001b[0m\n\u001b[0m              <&'a f32 as Div<f32>>\u001b[0m\n\u001b[0m              <&'a f64 as Div<f64>>\u001b[0m\n\u001b[0m              <&'a i128 as Div<i128>>\u001b[0m\n\u001b[0m              <&'a i16 as Div<i16>>\u001b[0m\n\u001b[0m              <&'a i32 as Div<i32>>\u001b[0m\n\u001b[0m              <&'a i64 as Div<i64>>\u001b[0m\n\u001b[0m              <&'a i8 as Div<i8>>\u001b[0m\n\u001b[0m              <&'a isize as Div<isize>>\u001b[0m\n\u001b[0m            and 54 others\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs","byte_start":18160,"byte_end":18166,"line_start":547,"line_end":547,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"                let offset = addr.as_u64() & 0o_777_777_7777;","highlight_start":35,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs","byte_start":18160,"byte_end":18166,"line_start":547,"line_end":547,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"                let offset = addr.as_u64() & 0o_777_777_7777;","highlight_start":35,"highlight_end":41}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:547:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m547\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let offset = addr.as_u64() & 0o_777_777_7777;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs","byte_start":18860,"byte_end":18866,"line_start":562,"line_end":562,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"                let offset = addr.as_u64() & 0o_777_7777;","highlight_start":35,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs","byte_start":18860,"byte_end":18866,"line_start":562,"line_end":562,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"                let offset = addr.as_u64() & 0o_777_7777;","highlight_start":35,"highlight_end":41}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:562:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m562\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                let offset = addr.as_u64() & 0o_777_7777;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageOffset>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs","byte_start":19510,"byte_end":19519,"line_start":582,"line_end":582,"column_start":22,"column_end":31,"is_primary":true,"text":[{"text":"        let offset = u64::from(addr.page_offset());","highlight_start":22,"highlight_end":31}],"label":"the trait `From<PageOffset>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageOffset>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:582:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m582\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let offset = u64::from(addr.page_offset());\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageOffset>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs","byte_start":21651,"byte_end":21661,"line_start":644,"line_end":644,"column_start":70,"column_end":80,"is_primary":true,"text":[{"text":"                        let start = table_addr + (offset_per_entry * (i as u64));","highlight_start":70,"highlight_end":80}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:644:70\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m644\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        let start = table_addr + (offset_per_entry * (i as u64));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\n"}
{"message":"cannot multiply `u32` by `u64`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs","byte_start":21649,"byte_end":21650,"line_start":644,"line_end":644,"column_start":68,"column_end":69,"is_primary":true,"text":[{"text":"                        let start = table_addr + (offset_per_entry * (i as u64));","highlight_start":68,"highlight_end":69}],"label":"no implementation for `u32 * u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Mul<u64>` is not implemented for `u32`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Mul<Rhs>`:\n  <&'a f32 as Mul<f32>>\n  <&'a f64 as Mul<f64>>\n  <&'a i128 as Mul<i128>>\n  <&'a i16 as Mul<i16>>\n  <&'a i32 as Mul<i32>>\n  <&'a i64 as Mul<i64>>\n  <&'a i8 as Mul<i8>>\n  <&'a isize as Mul<isize>>\nand 49 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot multiply `u32` by `u64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:644:68\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m644\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        let start = table_addr + (offset_per_entry * (i as u64));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `u32 * u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Mul<u64>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Mul<Rhs>`:\u001b[0m\n\u001b[0m              <&'a f32 as Mul<f32>>\u001b[0m\n\u001b[0m              <&'a f64 as Mul<f64>>\u001b[0m\n\u001b[0m              <&'a i128 as Mul<i128>>\u001b[0m\n\u001b[0m              <&'a i16 as Mul<i16>>\u001b[0m\n\u001b[0m              <&'a i32 as Mul<i32>>\u001b[0m\n\u001b[0m              <&'a i64 as Mul<i64>>\u001b[0m\n\u001b[0m              <&'a i8 as Mul<i8>>\u001b[0m\n\u001b[0m              <&'a isize as Mul<isize>>\u001b[0m\n\u001b[0m            and 49 others\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `PhysAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1762,"byte_end":1781,"line_start":42,"line_end":42,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct PhysAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs","byte_start":2263,"byte_end":2269,"line_start":59,"line_end":59,"column_start":56,"column_end":62,"is_primary":true,"text":[{"text":"        let virt = self.offset + frame.start_address().as_u64();","highlight_start":56,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs","byte_start":2263,"byte_end":2269,"line_start":59,"line_end":59,"column_start":56,"column_end":62,"is_primary":true,"text":[{"text":"        let virt = self.offset + frame.start_address().as_u64();","highlight_start":56,"highlight_end":62}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `PhysAddr` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:59:56\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m59\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let virt = self.offset + frame.start_address().as_u64();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:42:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct PhysAddr(u32);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":25870,"byte_end":25876,"line_start":781,"line_end":781,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"                offset,","highlight_start":17,"highlight_end":23}],"label":"expected `u64`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u32` to a `u64`","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":25870,"byte_end":25870,"line_start":781,"line_end":781,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"                offset,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"offset: ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":25876,"byte_end":25876,"line_start":781,"line_end":781,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                offset,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:781:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m781\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                offset,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u64`, found `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u32` to a `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m781\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10moffset: \u001b[0m\u001b[0moffset\u001b[0m\u001b[0m\u001b[38;5;10m.into()\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":26519,"byte_end":26525,"line_start":798,"line_end":798,"column_start":17,"column_end":23,"is_primary":true,"text":[{"text":"                offset,","highlight_start":17,"highlight_end":23}],"label":"expected `u64`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u32` to a `u64`","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":26519,"byte_end":26519,"line_start":798,"line_end":798,"column_start":17,"column_end":17,"is_primary":true,"text":[{"text":"                offset,","highlight_start":17,"highlight_end":17}],"label":null,"suggested_replacement":"offset: ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":26525,"byte_end":26525,"line_start":798,"line_end":798,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"                offset,","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:798:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m798\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                offset,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u64`, found `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u32` to a `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m798\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[38;5;10moffset: \u001b[0m\u001b[0moffset\u001b[0m\u001b[0m\u001b[38;5;10m.into()\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":27318,"byte_end":27324,"line_start":820,"line_end":820,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"            offset,","highlight_start":13,"highlight_end":19}],"label":"expected `u64`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u32` to a `u64`","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":27318,"byte_end":27318,"line_start":820,"line_end":820,"column_start":13,"column_end":13,"is_primary":true,"text":[{"text":"            offset,","highlight_start":13,"highlight_end":13}],"label":null,"suggested_replacement":"offset: ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs","byte_start":27324,"byte_end":27324,"line_start":820,"line_end":820,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"            offset,","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:820:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m820\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            offset,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u64`, found `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u32` to a `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m820\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10moffset: \u001b[0m\u001b[0moffset\u001b[0m\u001b[0m\u001b[38;5;10m.into()\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\n\n"}
{"message":"cannot add `u64` to `PhysAddr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mod.rs","byte_start":2047,"byte_end":2048,"line_start":48,"line_end":48,"column_start":89,"column_end":90,"is_primary":true,"text":[{"text":"            TranslateResult::Mapped { frame, offset, .. } => Some(frame.start_address() + offset),","highlight_start":89,"highlight_end":90}],"label":"no implementation for `PhysAddr + u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Add<u64>` is not implemented for `PhysAddr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Add<Rhs>`:\n  <PhysAddr as Add<u32>>\n  <PhysAddr as Add<usize>>","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot add `u64` to `PhysAddr`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:48:89\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            TranslateResult::Mapped { frame, offset, .. } => Some(frame.start_address() + offset),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `PhysAddr + u64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Add<u64>` is not implemented for `PhysAddr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Add<Rhs>`:\u001b[0m\n\u001b[0m             <PhysAddr as Add<u32>>\u001b[0m\n\u001b[0m             <PhysAddr as Add<usize>>\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `PhysAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1762,"byte_end":1781,"line_start":42,"line_end":42,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct PhysAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mod.rs","byte_start":15614,"byte_end":15620,"line_start":372,"line_end":372,"column_start":81,"column_end":87,"is_primary":true,"text":[{"text":"        let page = Page::containing_address(VirtAddr::new(frame.start_address().as_u64()));","highlight_start":81,"highlight_end":87}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mod.rs","byte_start":15614,"byte_end":15620,"line_start":372,"line_end":372,"column_start":81,"column_end":87,"is_primary":true,"text":[{"text":"        let page = Page::containing_address(VirtAddr::new(frame.start_address().as_u64()));","highlight_start":81,"highlight_end":87}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `PhysAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:372:81\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m372\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let page = Page::containing_address(VirtAddr::new(frame.start_address().as_u64()));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:42:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m42\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct PhysAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"the trait bound `u32: From<u64>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":2199,"byte_end":2206,"line_start":74,"line_end":74,"column_start":32,"column_end":39,"is_primary":true,"text":[{"text":"        if !address.is_aligned(S::SIZE) {","highlight_start":32,"highlight_end":39}],"label":"the trait `From<u64>` is not implemented for `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":2188,"byte_end":2198,"line_start":74,"line_end":74,"column_start":21,"column_end":31,"is_primary":false,"text":[{"text":"        if !address.is_aligned(S::SIZE) {","highlight_start":21,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `Into<u32>` for `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `addr::VirtAddr::is_aligned`","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":6549,"byte_end":6559,"line_start":187,"line_end":187,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"    pub fn is_aligned<U>(self, align: U) -> bool","highlight_start":12,"highlight_end":22}],"label":"required by a bound in this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":6608,"byte_end":6617,"line_start":189,"line_end":189,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"        U: Into<u32>,","highlight_start":12,"highlight_end":21}],"label":"required by this bound in `addr::VirtAddr::is_aligned`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u32: From<u64>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:74:32\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m74\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if !address.is_aligned(S::SIZE) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<u64>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `Into<u32>` for `u64`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `addr::VirtAddr::is_aligned`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:189:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m187\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn is_aligned<U>(self, align: U) -> bool\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m188\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        U: Into<u32>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `addr::VirtAddr::is_aligned`\u001b[0m\n\n"}
{"message":"the trait bound `u32: From<u64>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":2895,"byte_end":2902,"line_start":98,"line_end":98,"column_start":47,"column_end":54,"is_primary":true,"text":[{"text":"            start_address: address.align_down(S::SIZE),","highlight_start":47,"highlight_end":54}],"label":"the trait `From<u64>` is not implemented for `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":2884,"byte_end":2894,"line_start":98,"line_end":98,"column_start":36,"column_end":46,"is_primary":false,"text":[{"text":"            start_address: address.align_down(S::SIZE),","highlight_start":36,"highlight_end":46}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `Into<u32>` for `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `addr::VirtAddr::align_down`","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":6305,"byte_end":6315,"line_start":178,"line_end":178,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"    pub fn align_down<U>(self, align: U) -> Self","highlight_start":12,"highlight_end":22}],"label":"required by a bound in this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":6364,"byte_end":6373,"line_start":180,"line_end":180,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"        U: Into<u32>,","highlight_start":12,"highlight_end":21}],"label":"required by this bound in `addr::VirtAddr::align_down`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u32: From<u64>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:98:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m98\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            start_address: address.align_down(S::SIZE),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<u64>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `Into<u32>` for `u64`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `addr::VirtAddr::align_down`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:180:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn align_down<U>(self, align: U) -> Self\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m180\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        U: Into<u32>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `addr::VirtAddr::align_down`\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5015,"byte_end":5024,"line_start":172,"line_end":172,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(39..48, u64::from(p4_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:172:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m172\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(39..48, u64::from(p4_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5067,"byte_end":5076,"line_start":173,"line_end":173,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(30..39, u64::from(p3_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:173:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m173\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(30..39, u64::from(p3_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5136,"byte_end":5140,"line_start":174,"line_end":174,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":48,"highlight_end":52}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5122,"byte_end":5135,"line_start":174,"line_end":174,"column_start":34,"column_end":47,"is_primary":false,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":34,"highlight_end":47}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5140,"byte_end":5140,"line_start":174,"line_end":174,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:174:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Page::containing_address(VirtAddr::new(addr))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        Page::containing_address(VirtAddr::new(addr\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5513,"byte_end":5522,"line_start":189,"line_end":189,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(39..48, u64::from(p4_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:189:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m189\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(39..48, u64::from(p4_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5565,"byte_end":5574,"line_start":190,"line_end":190,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(30..39, u64::from(p3_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:190:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m190\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(30..39, u64::from(p3_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5617,"byte_end":5626,"line_start":191,"line_end":191,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(21..30, u64::from(p2_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:191:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m191\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(21..30, u64::from(p2_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5686,"byte_end":5690,"line_start":192,"line_end":192,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":48,"highlight_end":52}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5672,"byte_end":5685,"line_start":192,"line_end":192,"column_start":34,"column_end":47,"is_primary":false,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":34,"highlight_end":47}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":5690,"byte_end":5690,"line_start":192,"line_end":192,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:192:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Page::containing_address(VirtAddr::new(addr))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m192\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        Page::containing_address(VirtAddr::new(addr\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6092,"byte_end":6101,"line_start":208,"line_end":208,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(39..48, u64::from(p4_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:208:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m208\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(39..48, u64::from(p4_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6144,"byte_end":6153,"line_start":209,"line_end":209,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(30..39, u64::from(p3_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:209:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m209\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(30..39, u64::from(p3_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6196,"byte_end":6205,"line_start":210,"line_end":210,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(21..30, u64::from(p2_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:210:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m210\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(21..30, u64::from(p2_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"the trait bound `u64: From<PageTableIndex>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6248,"byte_end":6257,"line_start":211,"line_end":211,"column_start":31,"column_end":40,"is_primary":true,"text":[{"text":"        addr.set_bits(12..21, u64::from(p1_index));","highlight_start":31,"highlight_end":40}],"label":"the trait `From<PageTableIndex>` is not implemented for `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u64: From<PageTableIndex>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:211:31\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m211\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        addr.set_bits(12..21, u64::from(p1_index));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<PageTableIndex>` is not implemented for `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6317,"byte_end":6321,"line_start":212,"line_end":212,"column_start":48,"column_end":52,"is_primary":true,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":48,"highlight_end":52}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6303,"byte_end":6316,"line_start":212,"line_end":212,"column_start":34,"column_end":47,"is_primary":false,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":34,"highlight_end":47}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6321,"byte_end":6321,"line_start":212,"line_end":212,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"        Page::containing_address(VirtAddr::new(addr))","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:212:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Page::containing_address(VirtAddr::new(addr))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        Page::containing_address(VirtAddr::new(addr\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"no method named `as_u64` found for struct `addr::VirtAddr` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":1153,"byte_end":1172,"line_start":29,"line_end":29,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct VirtAddr(u32);","highlight_start":1,"highlight_end":20}],"label":"method `as_u64` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6737,"byte_end":6743,"line_start":227,"line_end":227,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"            self.start_address().as_u64()","highlight_start":34,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is an associated function with a similar name","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6737,"byte_end":6743,"line_start":227,"line_end":227,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"            self.start_address().as_u64()","highlight_start":34,"highlight_end":40}],"label":null,"suggested_replacement":"as_u32","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `as_u64` found for struct `addr::VirtAddr` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:227:34\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            self.start_address().as_u64()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: there is an associated function with a similar name: `as_u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:29:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct VirtAddr(u32);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmethod `as_u64` not found for this struct\u001b[0m\n\n"}
{"message":"cannot add `u64` to `addr::VirtAddr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":6944,"byte_end":6945,"line_start":236,"line_end":236,"column_start":55,"column_end":56,"is_primary":true,"text":[{"text":"        Page::containing_address(self.start_address() + rhs * S::SIZE)","highlight_start":55,"highlight_end":56}],"label":"no implementation for `addr::VirtAddr + u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Add<u64>` is not implemented for `addr::VirtAddr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Add<Rhs>`:\n  <addr::VirtAddr as Add<u32>>\n  <addr::VirtAddr as Add<usize>>","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot add `u64` to `addr::VirtAddr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:236:55\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m236\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Page::containing_address(self.start_address() + rhs * S::SIZE)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `addr::VirtAddr + u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Add<u64>` is not implemented for `addr::VirtAddr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Add<Rhs>`:\u001b[0m\n\u001b[0m              <addr::VirtAddr as Add<u32>>\u001b[0m\n\u001b[0m              <addr::VirtAddr as Add<usize>>\u001b[0m\n\n"}
{"message":"cannot subtract `u64` from `addr::VirtAddr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":7288,"byte_end":7289,"line_start":251,"line_end":251,"column_start":55,"column_end":56,"is_primary":true,"text":[{"text":"        Page::containing_address(self.start_address() - rhs * S::SIZE)","highlight_start":55,"highlight_end":56}],"label":"no implementation for `addr::VirtAddr - u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sub<u64>` is not implemented for `addr::VirtAddr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sub<Rhs>`:\n  <addr::VirtAddr as Sub<u32>>\n  <addr::VirtAddr as Sub<usize>>\n  <addr::VirtAddr as Sub>","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot subtract `u64` from `addr::VirtAddr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:251:55\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m251\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Page::containing_address(self.start_address() - rhs * S::SIZE)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `addr::VirtAddr - u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sub<u64>` is not implemented for `addr::VirtAddr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sub<Rhs>`:\u001b[0m\n\u001b[0m              <addr::VirtAddr as Sub<u32>>\u001b[0m\n\u001b[0m              <addr::VirtAddr as Sub<usize>>\u001b[0m\n\u001b[0m              <addr::VirtAddr as Sub>\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":7630,"byte_end":7637,"line_start":266,"line_end":266,"column_start":52,"column_end":59,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":52,"highlight_end":59}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:266:52\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (self.start_address - rhs.start_address) / S::SIZE\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":7587,"byte_end":7637,"line_start":266,"line_end":266,"column_start":9,"column_end":59,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":9,"highlight_end":59}],"label":"expected `u64`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":7564,"byte_end":7576,"line_start":265,"line_end":265,"column_start":32,"column_end":44,"is_primary":false,"text":[{"text":"    fn sub(self, rhs: Self) -> Self::Output {","highlight_start":32,"highlight_end":44}],"label":"expected `u64` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert a `u32` to a `u64`","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":7587,"byte_end":7587,"line_start":266,"line_end":266,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":7637,"byte_end":7637,"line_start":266,"line_end":266,"column_start":59,"column_end":59,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":59,"highlight_end":59}],"label":null,"suggested_replacement":").into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:266:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m265\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn sub(self, rhs: Self) -> Self::Output {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `u64` because of return type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (self.start_address - rhs.start_address) / S::SIZE\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u64`, found `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u32` to a `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0m(self.start_address - rhs.start_address) / S::SIZE\u001b[0m\u001b[0m\u001b[38;5;10m).into()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                                                  \u001b[0m\u001b[0m\u001b[38;5;10m++++++++\u001b[0m\n\n"}
{"message":"cannot divide `u32` by `u64`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":7628,"byte_end":7629,"line_start":266,"line_end":266,"column_start":50,"column_end":51,"is_primary":true,"text":[{"text":"        (self.start_address - rhs.start_address) / S::SIZE","highlight_start":50,"highlight_end":51}],"label":"no implementation for `u32 / u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Div<u64>` is not implemented for `u32`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Div<Rhs>`:\n  <&'a f32 as Div<f32>>\n  <&'a f64 as Div<f64>>\n  <&'a i128 as Div<i128>>\n  <&'a i16 as Div<i16>>\n  <&'a i32 as Div<i32>>\n  <&'a i64 as Div<i64>>\n  <&'a i8 as Div<i8>>\n  <&'a isize as Div<isize>>\nand 54 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot divide `u32` by `u64`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:266:50\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m266\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (self.start_address - rhs.start_address) / S::SIZE\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `u32 / u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Div<u64>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Div<Rhs>`:\u001b[0m\n\u001b[0m              <&'a f32 as Div<f32>>\u001b[0m\n\u001b[0m              <&'a f64 as Div<f64>>\u001b[0m\n\u001b[0m              <&'a i128 as Div<i128>>\u001b[0m\n\u001b[0m              <&'a i16 as Div<i16>>\u001b[0m\n\u001b[0m              <&'a i32 as Div<i32>>\u001b[0m\n\u001b[0m              <&'a i64 as Div<i64>>\u001b[0m\n\u001b[0m              <&'a i8 as Div<i8>>\u001b[0m\n\u001b[0m              <&'a isize as Div<isize>>\u001b[0m\n\u001b[0m            and 54 others\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":10904,"byte_end":10912,"line_start":378,"line_end":378,"column_start":47,"column_end":55,"is_primary":true,"text":[{"text":"            let max_page_addr = VirtAddr::new(u64::MAX) - (S::SIZE - 1);","highlight_start":47,"highlight_end":55}],"label":"expected `u32`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":10890,"byte_end":10903,"line_start":378,"line_end":378,"column_start":33,"column_end":46,"is_primary":false,"text":[{"text":"            let max_page_addr = VirtAddr::new(u64::MAX) - (S::SIZE - 1);","highlight_start":33,"highlight_end":46}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2748,"byte_end":2757,"line_start":71,"line_end":71,"column_start":16,"column_end":25,"is_primary":false,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":16,"highlight_end":25}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":2744,"byte_end":2747,"line_start":71,"line_end":71,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new(addr: u32) -> VirtAddr {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":10912,"byte_end":10912,"line_start":378,"line_end":378,"column_start":55,"column_end":55,"is_primary":true,"text":[{"text":"            let max_page_addr = VirtAddr::new(u64::MAX) - (S::SIZE - 1);","highlight_start":55,"highlight_end":55}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:378:47\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m378\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let max_page_addr = VirtAddr::new(u64::MAX) - (S::SIZE - 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u32`, found `u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(addr: u32) -> VirtAddr {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m378\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let max_page_addr = VirtAddr::new(u64::MAX\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m) - (S::SIZE - 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"message":"cannot subtract `u64` from `addr::VirtAddr`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs","byte_start":10914,"byte_end":10915,"line_start":378,"line_end":378,"column_start":57,"column_end":58,"is_primary":true,"text":[{"text":"            let max_page_addr = VirtAddr::new(u64::MAX) - (S::SIZE - 1);","highlight_start":57,"highlight_end":58}],"label":"no implementation for `addr::VirtAddr - u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sub<u64>` is not implemented for `addr::VirtAddr`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Sub<Rhs>`:\n  <addr::VirtAddr as Sub<u32>>\n  <addr::VirtAddr as Sub<usize>>\n  <addr::VirtAddr as Sub>","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: cannot subtract `u64` from `addr::VirtAddr`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page.rs:378:57\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m378\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let max_page_addr = VirtAddr::new(u64::MAX) - (S::SIZE - 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno implementation for `addr::VirtAddr - u64`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sub<u64>` is not implemented for `addr::VirtAddr`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `Sub<Rhs>`:\u001b[0m\n\u001b[0m              <addr::VirtAddr as Sub<u32>>\u001b[0m\n\u001b[0m              <addr::VirtAddr as Sub<usize>>\u001b[0m\n\u001b[0m              <addr::VirtAddr as Sub>\u001b[0m\n\n"}
{"message":"the trait bound `u32: From<u64>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page_table.rs","byte_start":2417,"byte_end":2431,"line_start":80,"line_end":80,"column_start":33,"column_end":47,"is_primary":true,"text":[{"text":"        assert!(addr.is_aligned(Size4KiB::SIZE));","highlight_start":33,"highlight_end":47}],"label":"the trait `From<u64>` is not implemented for `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page_table.rs","byte_start":2406,"byte_end":2416,"line_start":80,"line_end":80,"column_start":22,"column_end":32,"is_primary":false,"text":[{"text":"        assert!(addr.is_aligned(Size4KiB::SIZE));","highlight_start":22,"highlight_end":32}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  <f32 as From<i16>>\n  <f32 as From<i8>>\n  <f32 as From<u16>>\n  <f32 as From<u8>>\n  <f64 as From<f32>>\n  <f64 as From<i16>>\n  <f64 as From<i32>>\n  <f64 as From<i8>>\nand 71 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because of the requirements on the impl of `Into<u32>` for `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `PhysAddr::is_aligned`","code":null,"level":"note","spans":[{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":14862,"byte_end":14872,"line_start":512,"line_end":512,"column_start":12,"column_end":22,"is_primary":false,"text":[{"text":"    pub fn is_aligned<U>(self, align: U) -> bool","highlight_start":12,"highlight_end":22}],"label":"required by a bound in this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs","byte_start":14921,"byte_end":14930,"line_start":514,"line_end":514,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"        U: Into<u32>,","highlight_start":12,"highlight_end":21}],"label":"required by this bound in `PhysAddr::is_aligned`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `u32: From<u64>` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/structures/paging/page_table.rs:80:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m80\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert!(addr.is_aligned(Size4KiB::SIZE));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `From<u64>` is not implemented for `u32`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the following other types implement trait `From<T>`:\u001b[0m\n\u001b[0m              <f32 as From<i16>>\u001b[0m\n\u001b[0m              <f32 as From<i8>>\u001b[0m\n\u001b[0m              <f32 as From<u16>>\u001b[0m\n\u001b[0m              <f32 as From<u8>>\u001b[0m\n\u001b[0m              <f64 as From<f32>>\u001b[0m\n\u001b[0m              <f64 as From<i16>>\u001b[0m\n\u001b[0m              <f64 as From<i32>>\u001b[0m\n\u001b[0m              <f64 as From<i8>>\u001b[0m\n\u001b[0m            and 71 others\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because of the requirements on the impl of `Into<u32>` for `u64`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `PhysAddr::is_aligned`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/lenovo/.cargo/registry/src/github.com-1ecc6299db9ec823/x86_64-0.14.10/src/addr.rs:514:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m512\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn is_aligned<U>(self, align: U) -> bool\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m513\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    where\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m514\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        U: Into<u32>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `PhysAddr::is_aligned`\u001b[0m\n\n"}
{"message":"aborting due to 72 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 72 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0277, E0308, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0308, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
